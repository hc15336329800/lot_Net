
工厂回来了，闲暇时间继续完善多租户框架
===========================================================================

2024-12-27：
- 优化前端界面
- 后端登录代码增加组织子集，部门子集，并优化了新增的几个变量。
- 新增了全局筛选器，对角色进行了测试。
- 全局控制器增肌了多表操作的适配逻辑，避免了多表操作的冲突。
- 完善处理角色管理模块，代理角色只能查看自己及以下的数据，不能查看其他人的数据。（测试完毕）



2024-12-28：
- 增加用户部门表及相关文件
- 新增用户，查看用户的部门表测试通过

需要 ： 适配修改和删除 

2024-12-31：
- 修改控制台输出： 优化输出   减少多余输出 ，但是好像有点bug，注释LoggingMonitorAttribute中的输出可能会导致前段请求超时。



sass分层新的重构    整改：
===========================================================================


2025-03-09
- 重构多租户，开始进行分层， 将前端后台和用户分开，后台分为3种管理后台。

2025-03-10
- 控制器上的角色权限过滤修复正常


阶段：
- 系统管理员和集团管理员，登录分别展示不同页面。完成动态路由。
- 下一步，测试集团管理员管理页面（人员，角色，部门，菜单的管理）
- 下一步，优化集团管理员管理页面（人员，角色，部门，菜单的管理）

 核心逻辑：/getRouters 方法根据登录用户的 userType 来给路由的 Component 字段添加前缀，从而让前端在 src/views 不同文件夹下加载对应的页面




 ===========================================================================

 2025-06-26 
 - 继续重构多租户 准备用在物联网平台

 




 ===========================================================================


 2025-07-01:

 【平台（超级管理员）】
 └─【集团（租户）】
      ├─【集团管理员】
      ├─【集团用户】
      ├─【公司A（总公司）】
      │    ├─【公司管理员】
      │    └─【公司用户】
      └─【公司B】
           ├─【公司管理员】
           └─【公司用户】

    SUPER_ADMIN：超级管理员、
    GROUP_ADMIN：集团管理员、
    GROUP_USER：集团普通用户、
    COMPANY_ADMIN：公司管理员、
    COMPANY_USER：公司普通用户）

 注意： 系统在用户登录时会把租户 ID 写入 LoginUser（通常保存在 token/session 中）。因此在控制器或服务中需要获取当前租户 ID，只要直接调用 SecurityUtils.GetTenantId() 即可，例如：


 ===========================================================================

 2025-07-01 :

 - 完善了：集团管理员、公司管理员、公司用户   等了时看到的管理页面和管理数据





2025-07-02 ：

- 需要解决：如何区分集团还是公司！    用户=组织tid    .用户范围=组织tid+子集
- 发现一件事情：集团管理员 和  集团普通用户  以及其他的  可以实现互转  ，也就是说sys_manage_group文件夹可以是管理员也可以是普通用户（不给分配用户管理即可）
- 下拉框：   new ElSelect { Value = "COMPANY_ADMIN", Label = "公司管理员" },  new ElSelect { Value = "COMPANY_USER", Label = "公司普通用户" }   不能这样   各管各个不允许串通，创建对应的管理账户有管理账户去处理具体用户。

- 目前路由文件夹逻辑：
- views/sys_manage  : 超级管理员页面
- views/sys_manage_group  : 集团管理员页面
- views/sys_manage_company  : 公司管理员页面

- views/sys_user_group ： 集团用户
- views/sys_user_company ：公司用户、
- views/sys_user ： 普通用户、
- CommonPage ：用户的公共页面

 
2025-07-08 ：、
- 增加tcp透传小车的动画绘制
- 目前测试公司用户读取空调，列表展现正常
- 处理树型结构，当前菜单  和   下属角色菜单的勾选


CurrentTreeselect ： 获取当前用户角色下的全部菜单下拉树列表（含父子嵌套） 



2025-07-09 ：、
- 优化小车的轨道和点位
- 整改：菜单路由 ： 使用menu.Type区分事系统菜单还是通用业务菜单  （动态增加前缀）



2025-07-10：
- 优化登录接口耗时3s的问题  目前优化到1.3s  ,因为数据库在远程多次连接也会消耗时间。
- 切换到本地数据库，登录接口延迟只有300ms



注意： await SetUserAgent(loginUser); // 用于地理位置的网络调用  ，在令牌生成过程中会有一次网络请求，导致大约 1 秒的延迟。造成登录延迟


2025-07-12：
- tcp的监听和处理小成： 完善数据映射表iot_device_variable 后写入历史和实时表成功 ，关键是iot_device_variable这个表  这个表既是映射表也是实时表，不能使用产品的点位模版，因为后期设计的多租户等权限问题 没法分离。



2025-07-13

！！！，当前实现确实属于主动式的设备轮询方式，并不满足“服务器完全被动，等待设备连上再通信”的场景。  现在准备实现被动模式。

 在当前实现中，TcpService 仅在一个端口上监听设备接入，端口值由配置项 TcpServer:Port 指定，默认为 5003。监听线程在启动时创建 TcpListener 并接受所有设备连接。
一旦接收到设备连接，该服务会将设备 ID 与 TcpClient 存入 _clients 字典，之后就可以通过 SendAsync 方法在同一连接上发送指令并读取响应。
由于每个 TCP 连接天生支持全双工通信，服务端已经能够在同一端口（如 5003）同时接受设备连接并向其回发指令，不需要再为“发送指令”独立开辟端口 5005。若要向已上线的设备发送指令，可直接在业务逻辑或 API 中调用 TcpService.SendAsync 并传入设备 ID 与指令数据即可。这样能重用现有连接，避免额外维护新的端口和连接管理逻辑。
若希望测试此逻辑，可在设备完成注册后，通过 TcpService.SendAsync 发送 Modbus 帧并检查设备是否收到并回应即可。这里只需要确保设备使用的注册包能在数据库中匹配到对应的 AutoRegPacket 条目。