
工厂回来了，闲暇时间继续完善多租户框架
===========================================================================

2024-12-27：
- 优化前端界面
- 后端登录代码增加组织子集，部门子集，并优化了新增的几个变量。
- 新增了全局筛选器，对角色进行了测试。
- 全局控制器增肌了多表操作的适配逻辑，避免了多表操作的冲突。
- 完善处理角色管理模块，代理角色只能查看自己及以下的数据，不能查看其他人的数据。（测试完毕）



2024-12-28：
- 增加用户部门表及相关文件
- 新增用户，查看用户的部门表测试通过



2024-12-31：
- 修改控制台输出： 优化输出   减少多余输出 ，但是好像有点bug，注释LoggingMonitorAttribute中的输出可能会导致前段请求超时。



sass分层新的重构    整改：
===========================================================================


2025-03-09
- 重构多租户，开始进行分层， 将前端后台和用户分开，后台分为3种管理后台。

2025-03-10
- 控制器上的角色权限过滤修复正常


阶段：
- 系统管理员和集团管理员，登录分别展示不同页面。完成动态路由。
- 下一步，测试集团管理员管理页面（人员，角色，部门，菜单的管理）
- 下一步，优化集团管理员管理页面（人员，角色，部门，菜单的管理）

 核心逻辑：/getRouters 方法根据登录用户的 userType 来给路由的 Component 字段添加前缀，从而让前端在 src/views 不同文件夹下加载对应的页面




 ===========================================================================

 2025-06-26 
 - 继续重构多租户 准备用在物联网平台

 




 ===========================================================================


 2025-07-01:

 【平台（超级管理员）】
 └─【集团（租户）】
      ├─【集团管理员】
      ├─【集团用户】
      ├─【公司A（总公司）】
      │    ├─【公司管理员】
      │    └─【公司用户】
      └─【公司B】
           ├─【公司管理员】
           └─【公司用户】

    SUPER_ADMIN：超级管理员、
    GROUP_ADMIN：集团管理员、
    GROUP_USER：集团普通用户、
    COMPANY_ADMIN：公司管理员、
    COMPANY_USER：公司普通用户）

 注意： 系统在用户登录时会把租户 ID 写入 LoginUser（通常保存在 token/session 中）。因此在控制器或服务中需要获取当前租户 ID，只要直接调用 SecurityUtils.GetTenantId() 即可，例如：


 ===========================================================================

 2025-07-01 :

 - 完善了：集团管理员、公司管理员、公司用户   等了时看到的管理页面和管理数据





2025-07-02 ：

- 需要解决：如何区分集团还是公司！    用户=组织tid    .用户范围=组织tid+子集
- 发现一件事情：集团管理员 和  集团普通用户  以及其他的  可以实现互转  ，也就是说sys_manage_group文件夹可以是管理员也可以是普通用户（不给分配用户管理即可）
- 下拉框：   new ElSelect { Value = "COMPANY_ADMIN", Label = "公司管理员" },  new ElSelect { Value = "COMPANY_USER", Label = "公司普通用户" }   不能这样   各管各个不允许串通，创建对应的管理账户有管理账户去处理具体用户。

- 目前路由文件夹逻辑：
- views/sys_manage  : 超级管理员页面
- views/sys_manage_group  : 集团管理员页面
- views/sys_manage_company  : 公司管理员页面

- views/sys_user_group ： 集团用户
- views/sys_user_company ：公司用户、
- views/sys_user ： 普通用户、
- CommonPage ：用户的公共页面

 
2025-07-08 ：、
- 增加tcp透传小车的动画绘制
- 目前测试公司用户读取空调，列表展现正常
- 处理树型结构，当前菜单  和   下属角色菜单的勾选


CurrentTreeselect ： 获取当前用户角色下的全部菜单下拉树列表（含父子嵌套） 



2025-07-09 ：、
- 优化小车的轨道和点位
- 整改：菜单路由 ： 使用menu.Type区分事系统菜单还是通用业务菜单  （动态增加前缀）



2025-07-10：
- 优化登录接口耗时3s的问题  目前优化到1.3s  ,因为数据库在远程多次连接也会消耗时间。
- 切换到本地数据库，登录接口延迟只有300ms



注意： await SetUserAgent(loginUser); // 用于地理位置的网络调用  ，在令牌生成过程中会有一次网络请求，导致大约 1 秒的延迟。造成登录延迟


2025-07-12：
- tcp的监听和处理小成： 完善数据映射表iot_device_variable 后写入历史和实时表成功 ，关键是iot_device_variable这个表  这个表既是映射表也是实时表，不能使用产品的点位模版，因为后期设计的多租户等权限问题 没法分离。



2025-07-13：

！！！，当前实现确实属于主动式的设备轮询方式，并不满足“服务器完全被动，等待设备连上再通信”的场景。  现在准备实现被动模式。

 在当前实现中，TcpService 仅在一个端口上监听设备接入，端口值由配置项 TcpServer:Port 指定，默认为 5003。监听线程在启动时创建 TcpListener 并接受所有设备连接。
一旦接收到设备连接，该服务会将设备 ID 与 TcpClient 存入 _clients 字典，之后就可以通过 SendAsync 方法在同一连接上发送指令并读取响应。
由于每个 TCP 连接天生支持全双工通信，服务端已经能够在同一端口（如 5003）同时接受设备连接并向其回发指令，不需要再为“发送指令”独立开辟端口 5005。若要向已上线的设备发送指令，可直接在业务逻辑或 API 中调用 TcpService.SendAsync 并传入设备 ID 与指令数据即可。这样能重用现有连接，避免额外维护新的端口和连接管理逻辑。
若希望测试此逻辑，可在设备完成注册后，通过 TcpService.SendAsync 发送 Modbus 帧并检查设备是否收到并回应即可。这里只需要确保设备使用的注册包能在数据库中匹配到对应的 AutoRegPacket 条目。


一个TCP连接（比如设备上报连接或主动注册成功的那一条），在不同代码模块/线程里同时读写同一个TcpClient的Stream会出错.


完善收发：添加了每个设备的信号量队列，以便并发命令共享一个 TCP 连接而不会发生冲突，当设备连接或断开连接时创建和处置这些信号量


TestRead通过反射和动态调用来解析TcpService，增加了复杂性并失去了编译时检查，需要整改。


2025-07-13 22:38 ：

- 初步测试成功：1、首次通讯正确解析注册包  2、发送消息给客户端成功   3、正确解析客户端的回应 ，并正确修改传感器最新数值，并插入正确的历史数据。
- 需要解决的问题：/TestRead接口发送指令等待回应  及时客户端应答了  依然没有返回  ，如果点击了取消请求， 下次在请求接口就会返回： 
 {
    "msg": "无可用连接或发送失败",
    "code": 500
}    


======================================================================================================================================================

关于轮训的疑惑：

- 目前，每个点位的数据读取是顺序执行的：发送完指令后必须收到完整的响应（ReadExactAsync）才会继续下一个点位或下一轮轮询。即使外部同时触发多次 SendAsync，也会被信号量串行化，不会在一个连接上并发读取。
- 若设备本身限制“每秒只能处理一个点”，目前的逻辑是一次轮询会连续发送所有点位的读取指令，只要设备能及时回复，下一条指令才会发送；不会出现上一条还没读完就开始读下一条的情况。若设备回复非常慢，则轮询会等待其响应，可能延长整体耗时。若需要完全限制发送频率，可考虑在 PollAsync 中为每个点位之间再加入适当的 Delay。



2025-07-30 ：
- 重构完毕： 1、 设备点位关联逻辑重构完毕（由原来的复制点位到现在的引用点位 实现动态）  2、TestRead握手接口正确得到回应    3、初测设备握手成功 回复成功  实收数据显示正常

2025-07-31：
- 优化：  根据注册包查询设备   ，增加注册包字段索引
- 优化： 1、优化生成注册数据包格式  2、增加注册包响应代码


2025-08-02：
- 从代码实现来看，当前的 TCP 服务可以同时处理多个客户端主动上传的消息：
- 服务端通过 ConcurrentDictionary 管理所有在线客户端及其发送队列，实现并发访问安全
- 监听线程对每个新连接调用 HandleClientAsync 并行处理，从而在不同 Task 中独立接收数据
- 每个连接在注册成功后与设备 ID 关联并交给协议处理器，之后持续读取并解析该客户端的 Modbus RTU 数据
- 因此，当多台 RTU 设备同时连接并主动上传数据时，当前逻辑可以并发地接收、验证和解析各自的消息流。


2025-08-02：

引入并发映射来记录活动的从属地址，防止多个设备共享相同的地址并破坏状态
在 Modbus RTU 处理循环中添加逻辑，以跳过重复使用已占用从属地址的设备的数据并注册第一个设备的地址
连接关闭时清理跟踪的从属地址和起始地址元数据，确保新设备可以安全地重用地址


2025-08-20：

- SysJobIotDto 目前继承自 SysJobDto，而 SysJobDto 又继承自 BaseDto。sys_job_iot 表仅包含 IoT 任务扩展字段，与 sys_job 中的大量调度字段并不匹配。直接继承 SysJobDto 会让 SysJobIotDto 持有许多与其实体不对应的属性，造成 DTO 映射混乱和潜在的序列化/验证问题。需要整改保持明了性。
- 目前可以使用sys_job_iot 与 sys_job 通过 job_id 一对一关联，可以按照“前端提供全量数据 → 后端拆分入库 → 查询时再组合返回”的模式实现

















